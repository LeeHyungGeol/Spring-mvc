# 스프링 MVC - 웹 페이지 만들기<br/>## 목차- 타임리프 간단히 알아보기- 상품 등록 -  @GetMapping("/add"), @PostMapping("/add")# 💡타임리프 간단히 알아보기<details><summary>`/resources/templates/basic/items.html` 예시</summary><div markdown="1">```thymeleafexpressions<!DOCTYPE HTML><html xmlns:th="http://www.thymeleaf.org"><head>  <meta charset="utf-8">  <link href="../css/bootstrap.min.css"        th:href="@{/css/bootstrap.min.css}" rel="stylesheet"></head><body><div class="container" style="max-width: 600px">  <div class="py-5 text-center">    <h2>상품 목록</h2></div>  <div class="row">    <div class="col">      <button class="btn btn-primary float-end"              onclick="location.href='addForm.html'"              th:onclick="|location.href='@{/basic/items/add}'|" type="button">상품 등록      </button>    </div>  </div>  <hr class="my-4">  <div>    <table class="table">      <thead>      <tr>        <th>ID</th>        <th>상품명</th>        <th>가격</th>        <th>수량</th>      </tr>      </thead>      <tbody>      <tr th:each="item : ${items}">        <td><a href="item.html" th:href="@{/basic/items/{itemId} (itemId=${item.id})}"               th:text="${item.id}">회원id</a></td>        <td><a href="item.html" th:href="@{|/basic/items/${item.id}|}" th:text="${item.itemName}">상품명</a>        </td>        <td th:text="${item.price}">10000</td>        <td th:text="${item.quantity}">10</td>      </tr>      </tbody>    </table>  </div></div> <!-- /container --></body></html>```</div></details>## **타임리프 사용 선언**`<html xmlns:th="http://www.thymeleaf.org">`<br/><br/>## **속성 변경 - th:href**`th:href="@{/css/bootstrap.min.css}"`- `href="value1"` 을 `th:href="value2"` 의 값으로 변경한다.- 타임리프 뷰 템플릿을 거치게 되면 원래 값을 th:xxx 값으로 변경한다. 만약 값이 없다면 새로 생성한다.- HTML을 그대로 볼 때는 href 속성이 사용되고, 뷰 템플릿을 거치면 th:href 의 값이 href 로 대체되면서 동적으로 변경할 수 있다.- 대부분의 HTML 속성을 `th:xxx` 로 변경할 수 있다.![image](https://user-images.githubusercontent.com/83503188/206420094-5301689b-2a31-452b-b45c-ddfbffe92e68.png)- 기존 소스![image](https://user-images.githubusercontent.com/83503188/206420329-b64770fe-fa80-4c3e-b472-8dbd31f3d405.png)- `th:href` 적용후 뷰 템플릿을 거친 소스- th가 존재하면 기존의 href 를 th:href 로 변경한다.    - 덮어쓰기<br/><br/>## **타임리프 핵심**서버 사이드 렌더링되면 기존 속성, 값을 치환하는 것이 타임리프의 핵심이다.- 핵심은 `th:xxx` 가 붙은 부분은 서버사이드에서 렌더링 되고, 기존 것을 대체한다. `th:xxx` 이 없으면 기존 html의 xxx 속성이 그대로 사용된다.- HTML을 파일로 직접 열었을 때, `th:xxx` 가 있어도 웹 브라우저는 `th:` 속성을 알지 못하므로 무시한다.- 따라서 HTML을 파일 보기를 유지하면서 템플릿 기능도 할 수 있다.<br/><br/>## **URL 링크 표현식 - @{...},**`th:href="@{/css/bootstrap.min.css}"`- `@{...}` : 타임리프는 URL 링크를 사용하는 경우 `@{...}` 를 사용한다. 이것을 URL 링크 표현식이라 한다.- URL 링크 표현식을 사용하면 서블릿 컨텍스트를 자동으로 포함한다.<br/><br/>## **상품 등록 폼으로 이동****속성 변경 - th:onclick**- `onclick="location.href='addForm.html'"`- `th:onclick="|location.href='@{/basic/items/add}'|"`  여기에는 다음에 설명하는 리터럴 대체 문법이 사용되었다. 자세히 알아보자.**리터럴 대체 - |...|**|...| :이렇게 사용한다.- 타임리프에서 문자와 표현식 등은 분리되어 있기 때문에 더해서 사용해야 한다.    - `<span th:text="'Welcome to our application, ' + ${user.name} + '!'">`- 다음과 같이 리터럴 대체 문법을 사용하면, 더하기 없이 편리하게 사용할 수 있다.    - `<span th:text="|Welcome to our application, ${user.name}!|">`- 결과를 다음과 같이 만들어야 하는데    - `location.href='/basic/items/add'`- 그냥 사용하면 문자와 표현식을 각각 따로 더해서 사용해야 하므로 다음과 같이 복잡해진다.    - `th:onclick="'location.href=' + '\'' + @{/basic/items/add} + '\''"`- 리터럴 대체 문법을 사용하면 다음과 같이 편리하게 사용할 수 있다.    - `th:onclick="|location.href='@{/basic/items/add}'|"`<br/><br/>## **반복 출력 - th:each**- `<tr th:each="item : ${items}">`- 반복은 `th:each` 를 사용한다. 이렇게 하면 모델에 포함된 items 컬렉션 데이터가 item 변수에 하나씩 포함되고, 반복문 안에서 item 변수를 사용할 수 있다.- 컬렉션의 수 만큼 <`tr>..</tr>` 이 하위 테그를 포함해서 생성된다.<br/><br/>## **변수 표현식 - ${...}**- `<td th:text="${item.price}">10000</td>`- 모델에 포함된 값이나, 타임리프 변수로 선언한 값을 조회할 수 있다.- 프로퍼티 접근법을 사용한다. ( `item.getPrice()` )<br/><br/>## **내용 변경 - th:text**- `<td th:text="${item.price}">10000</td>`- 내용의 값을 `th:text` 의 값으로 변경한다.- 여기서는 10000을 `${item.price}` 의 값으로 변경한다.<br/><br/>## **URL 링크 표현식2 - @{...},**- `th:href="@{/basic/items/{itemId}(itemId=${item.id})}"`- 상품 ID를 선택하는 링크를 확인해보자.- URL 링크 표현식을 사용하면 경로를 템플릿처럼 편리하게 사용할 수 있다.- 경로 변수( {itemId} ) 뿐만 아니라 쿼리 파라미터도 생성한다.- 예) `th:href="@{/basic/items/{itemId}(itemId=${item.id}, query='test')}"`    - 생성 링크: `http://localhost:8080/basic/items/1?query=test`<br/><br/>## **URL 링크 간단히**- `th:href="@{|/basic/items/${item.id}|}"`- 상품 이름을 선택하는 링크를 확인해보자.- 리터럴 대체 문법을 활용해서 간단히 사용할 수도 있다.<br/>> ### 참고>> 타임리프는 순수 HTML 파일을 웹 브라우저에서 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을> 거치면 동적으로 변경된 결과를 확인할 수 있다. JSP를 생각해보면, JSP 파일은 웹 브라우저에서 그냥 열면> JSP 소스코드와 HTML이 뒤죽박죽 되어서 정상적인 확인이 불가능하다. 오직 서버를 통해서 JSP를 열어야 한다.> 이렇게 순수 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 네츄럴 템플릿 (natural templates)이라 한다.<br/><br/><br/># 💡상품 등록 -  @GetMapping("/add"), @PostMapping("/add")**속성 변경 - th:action** - `th:action`- HTML form에서 `action` 에 값이 없으면 현재 URL에 데이터를 전송한다. - 상품 등록 폼의 URL과 실제 상품 등록을 처리하는 URL을 똑같이 맞추고 HTTP 메서드로 두 기능을 구분한다.   - 상품 등록 폼: GET `/basic/items/add`  - 상품 등록 처리: POST `/basic/items/add`**이렇게 하면 하나의 URL로 등록 폼과, 등록 처리를 깔끔하게 처리할 수 있다.**<br/><br/><br/># 💡상품 등록 처리 - @ModelAttribute상품 등록 폼은 다음 방식으로 서버에 데이터를 전달한다.- **POST - HTML Form**  - `content-type: application/x-www-form-urlencoded`  - 메시지 바디에 쿼리 파리미터 형식으로 전달 `itemName=itemA&price=10000&quantity=10`  - 예) 회원 가입, 상품 주문, HTML Form 사용요청 파라미터 형식을 처리해야 하므로 `@RequestParam` 을 사용하자## **⚡️ 1. 상품 등록 처리 - @RequestParam**```java@PostMapping("/add")public String addItemV1(@RequestParam String itemName,                         @RequestParam int price,                        @RequestParam Integer quantity,                        Model model) {    Item item = new Item();    item.setItemName(itemName);    item.setPrice(price);    item.setQuantity(quantity);        itemRepository.save(item);        model.addAttribute("item", item);    return "/basic/item";}```<br/><br/>## **⚡️ 2. 상품 등록 처리 - @ModelAttribute**```java/** * @ModelAttribute("item") Item item * model.addAttribute("item", item); 자동 추가 */@PostMapping("/add")public String addItemV2(@ModelAttribute("item") Item item) {  itemRepository.save(item);  return "basic/item";}```**@ModelAttribute - 요청 파라미터 처리**- `@ModelAttribute` 는 Item 객체를 생성하고, 요청 파라미터의 값을 **프로퍼티 접근법(setXxx)** 으로 입력해준다.**@ModelAttribute - Model 추가**- `@ModelAttribute` 는 중요한 한가지 기능이 더 있는데, 바로 모델(Model)에 `@ModelAttribute` 로 지정한 객체를 자동으로 넣어준다. - 지금 코드를 보면 `model.addAttribute("item", item)` 가 주석처리 되어 있어도 잘 동작하는 것을 확인할 수 있다.모델에 데이터를 담을 때는 이름이 필요하다. 이름은 `@ModelAttribute` 에 지정한 `name(value)` 속성을 사용한다.만약 다음과 같이 `@ModelAttribute` 의 이름을 다르게 지정하면 다른 이름으로 모델에 포함된다.- `@ModelAttribute("hello") Item item` -> 이름을 hello 로 지정- `model.addAttribute("hello", item);` -> 모델에 hello 이름으로 저장## **⚡️ 3. 상품 등록 처리 - ModelAttribute 이름 생략**```java/** * @ModelAttribute name 생략 가능 * model.addAttribute(item); 자동 추가, 생략 가능 * 생략시 model에 저장되는 name은 클래스명 첫글자만 소문자로 등록 Item -> item */@PostMapping("/add")public String addItemV3(@ModelAttribute Item item) {  itemRepository.save(item);  return "basic/item";}````@ModelAttribute `의 이름을 생략할 수 있다.**주의**`@ModelAttribute` 의 이름을 생략하면 모델에 저장될 때 **클래스명을 사용**한다. 이때 **클래스의 첫글자만 소문자로 변경해서 등록**한다.- 예) `@ModelAttribute` 클래스명 -> 모델에 자동 추가되는 이름  - `Item` -> `item`  - `HelloWorld` -> `helloWorld`<br/><br/>## **⚡️ 4. 상품 등록 처리 - ModelAttribute 전체 생략**```java/** * @ModelAttribute 자체 생략 가능 * model.addAttribute(item) 자동 추가 */@PostMapping("/add")public String addItemV4(Item item) {  itemRepository.save(item);  return "basic/item";}````@ModelAttribute` 자체도 생략가능하다. 대상 객체는 모델에 자동 등록된다. 나머지 사항은 기존과 동일하다.* **@RequestParam :** String, int, Integer 와 같은 String(문자열), primitive, Wrapper 클래스* **@ModelAttribute :** 나머지(argument resolver 로 지정해둔 타입 외의 레퍼 클래스)<br/><br/><br/># 💡Post,Redirect,Get![prg-before-process](https://user-images.githubusercontent.com/50267433/128503254-d800ddc8-e3f1-4f9e-a91e-4dee8213732d.PNG)```java@PostMapping("/add")public String addItemV5(Item item) {    itemRepository.save(item);    return "basic/items";}```상품을 저장하는 `POST 핸들러`가 있다고 가정한다.          해당 URL로 API를 요청할 경우 핸들러는 내부 로직을 실행하고 `basic/items`로 데이터 흐름을 이동시킨다.그런데 여기에는 해당 핸들러에는 심각한 문제가 있다.        만약, 상품 등록을 완료하고 웹 브라우저의 **새로고침 버튼을 클릭한다면**            **계속해서 POST 핸들러에 요청을 주어 상품이 등록되는 것을 알 수 있다.**![prg-before-request](https://user-images.githubusercontent.com/50267433/128503390-d351c4c0-af5b-48a4-a458-a7e0b011a301.PNG)그 이유는 위 그림을 통해서 확인할 수 있다.  ***웹 브라우저의 새로 고침: 마지막에 했던 행위를 다시 한다!!!***이전 요청은, 상품 등록 폼에서 데이터를 입력하고 저장을 선택하면 `POST /add + 상품 데이터`를 서버로 전송했다.   이 상태에서 **새로 고침을 또 선택하면 마지막에 전송한 `POST /add + 상품 데이터`를 서버로 다시 전송하게 된다.**   **그래서 내용은 같고, ID만 다른 상품 데이터가 계속 쌓이게 된다.**<br/>## 이 문제를 어떻게 해결할 수 있을까?🤔-> POST, Redirect, GET![prg-after-request](https://user-images.githubusercontent.com/50267433/128503634-1d316f61-46ba-4661-82c1-44adc3b274a8.PNG)웹 브라우저의 새로 고침은 마지막에 서버에 전송한 데이터를 다시 전송한다.새로 고침 문제를 해결하려면 **상품 저장 후에 View Template 으로 이동하는 것이 아니라,   상품 상세 화면으로 `Redirect` 를 호출해주면 된다.**```java@PostMapping("/add")public String addItemV5(Item item) {    itemRepository.save(item);    return "redirect:/basic/items/" + item.getId();}```웹 브라우저는 리다이렉트의 영향으로 상품 저장 후에 실제 상품 상세 화면으로 다시 이동한다.       따라서 마지막에 호출한 내용이 상품 상세 화면인 GET /items/{id} 가 되는 것이다.         이러한 문제 해결 방식을 **`PRG Post/Redirect/Get`** 라 한다.이후 새로고침을 해도 상품 상세 화면으로 이동하게 되므로 새로 고침 문제를 해결할 수 있다.<br/><br/>> ### **주의**     > `"redirect:/basic/items/" + item.getId()` redirect 에서 `+item.getId()` 처럼       > **URL에 변수를 더해서 사용하는 것은 URL 인코딩이 안되기 때문에 위험하다.**             > 다음에 설명하는 **`RedirectAttributes`** 를 사용하자.<br/><br/><br/># RedirectAttributes상품을 저장하고 상품 상세 화면으로 리다이렉트 한 것 까지는 좋았다.        그런데 고객 입장에서 저장이 잘 된 것인지 안 된 것인지 확신이 들지 않는다.         그래서 저장이 잘 되었으면 상품 상세 화면에 `"저장되었습니다"`라는 메시지를 보여달라는 요구사항이 왔다.        이를 간단하게 해결해보자.```java@PostMapping("/add")public String addItemV6(Item item, RedirectAttributes redirectAttributes) {    Item savedItem = itemRepository.save(item);    redirectAttributes.addAttribute("itemId", savedItem.getId());    redirectAttributes.addAttribute("status", true);    return "redirect:/basic/items/{itemId}";}````RedirectAttributes`를 사용하면 **URL 인코딩**, **pathVariable**, **쿼리 파라미터**까지 처리해준다.      `redirectAttributes.addAttribute("itemId", savedItem.getId());`를 입력하면             `savedItem.getId()`라는 데이터가 PathVariable로 `redirect:/basic/items/{itemId}`에 바인딩 된다.       그리고 **나머지는 쿼리 파라미터로 처리된다. `?status=true`**           즉, `/basic/items/1?status=true`로 리다이렉트 요청을 보낸다.```java@GetMapping("/basic/items/{itemId}")public String addItemV6(@PathVariable("itemId") Long itemId) {    return "redirect:/basic/items/{itemId}";}```더불어, 기존 request에서 `@PathVariable`로 받은 변수 이름을     리다이렉트에도 동일하기 입력을 하면 별다른 설정 없이도 바인딩 된다.```html   <h2 th:if="${param.status}" th:text="'저장 완료!'"></h2>```   * th:if : 해당 조건이 참이면 실행* ${param.status} : 타임리프에서 쿼리 파라미터를 편리하게 조회하는 기능쿼리 파라미터를 이용해 이와 같이 저장 완료 여부를 제공해줄 수 있다.       