# 스프링 MVC - 기본 기능<br/>## 목차- 로깅 - SLF4J, Logback- 요청 매핑- 요청 매핑 - API 예시- HTTP 요청 - 기본, 헤더 조회- HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form- HTTP 요청 파라미터 - @ModelAttribute- HTTP 요청 메시지 - 단순 텍스트- HTTP 요청 메시지 - JSON- HTTP 응답 - 정적 리소스, 뷰 템플릿- HTTP 응답 - HTTP API, 메시지 바디에 직접 입력- HttpMessageConverter<br/><br/><br/># 💡로깅 > 운영 시스템에서는, 일반적인 콘솔 출력(sout) 대신 **로깅 라이브러리**를 사용해서 **로그를 출력**한다.<br/>## ⚡️ 로깅 라이브러리 - SLF4J, Logback스프링 부트는 기본적으로 `spring-boot-starter-logging` 라이브러리를 제공한다.**스프링 부트 로깅 라이브러리*** SLF4J - http://www.slf4j.org* Logback - http://logback.qos.ch`SLF4J`는 다양한 로깅 라이브러리를 사용할 수 있도록 정의된 **통합 로그 인터페이스다.**                  구현체로는 `Logback`, `Log4J`, `Log4J2` 등등이 있으며 **`Spring Boot` 는 `Logback`를 지원해준다.**              **즉, 스프링부트는 SLF4J 인터페이스 및 LogBack 구현체를 제공해 로깅 기능을 지원해준다는 의미이다.**<br/>## ⚡️ 로그 선언**방법1**```javaprivate Logger log = LoggerFactory.getLogger(getClass());```**방법2**```javaprivate static final Logger log = LoggerFactory.getLogger(Xxx.class)```다양한 Logger 인터페이스가 존재하는데 우리가 사용할 것은 SLF4J의 Logger 인터페이스다.           `LoggerFactory.getLogger()`를 통해 SLF4J 구현체를 생성하는데 이때, 현재 클래스 정보를 입력해준다.         위 두 방법 모두 사실은 똑같은 값을 사용하는 것이기에 크게 차이가 없다.**롬복 사용**```java@Slf4jpublic class SampleClass {}```lombok을 의존성 주입 받았다면 간단히 `@Slf4j`만으로도 구현할 수 있다.        이 때 **Logger 참조변수의 이름은 `log`로 사용해야 한다.**<br/>## ⚡️ 로그 호출```java//@Slf4j@RestControllerpublic class LogTestController {    private final Logger log = LoggerFactory.getLogger(getClass());     @RequestMapping("/log-test")    public String logTest() {        String name = "Spring";        log.trace("trace log={}", name);        log.debug("debug log={}", name);        log.info(" info log={}", name);        log.warn(" warn log={}", name);        log.error("error log={}", name);         //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X        log.debug("String concat log=" + name);        return "ok";     }}``````로그가 출력되는 포멧 : 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지```  로그를 호출함에 있어 **로그 레벨**이라는 개념부터 짚고 넘어가고자 한다.         **로그 레벨**이란, **최소 로그 출력 범위**를 나타내는 것으로           **특정 로그 레벨이 지정이 되면 그 이하 로그 레벨을 출력이 되지 않는다.*** **LOG LEVEL:** `TRACE` > `DEBUG` > `INFO` > `WARN` > `ERROR`만약, 애플리케이션의 로그 레벨을 `INFO`로 설정한다면               하위 레벨인 `TRACE`, `DEBUG`는 출력이 되지 않고 `INFO`, `WARN`, `ERROR `이 출력된다.이러한 로그 레벨 설정은 스프링 설정 파일(properties/yml)을 통해 손 쉽게 설정할 수 있다.**application.properties**```properties#전체 로그 레벨 설정(기본 info)logging.level.root=info#hello.springmvc 패키지와 그 하위 로그 레벨 설정logging.level.com.brothergeol.mvc=debug```**root**는 **모든 영역의 로그 레벨을 설정**하며 단 하나의 로그 레벨만을 가질 수 있다.      **명시적인 패키지** 입력은 해당 패키지와 그 하위 패키지에 입력한 로그 레벨이 설정된다.실무에서는 주로 아래와 같은 로그 레벨을 설정한다.* 개발 서버는 debug 출력* 운영 서버는 info 출력로그 레벨 설정을 끝맞췄다면 로그 호출에 대해서 언급하고자 한다.       위 코드에서도 나왔듯이 `log.debug("data="+data)`는 매우 좋지 않은 방법이기에<br/>## ⚡️ 올바른 로그 사용법```java//@Slf4j@RestControllerpublic class LogTestController {     private final Logger logger = LoggerFactory.getLogger(getClass());        @RequestMapping("/log-test")     public String logTest() {      String name = "SpringLogTest";      System.out.println("name = " + name);      logger.trace("info log ={}", name);      logger.debug("info log ={}", name);      logger.info("info log ={}", name);      logger.warn("info log ={}", name);      logger.error("info log ={}", name);      //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X      log.debug("String concat log=" + name);      return "ok";    }}```위 코드에서도 언급했듯이 `log.debug("String concat log=" + name);`는 좋지 않은 방법이다.    로그 레벨이 맞지 않으면 해당 메서드를 호출하지도 않지만,       **연산 로직**이 들어가있다면 로그 레벨이 어떻든지 간에 로직이 일단 실행되기에 별로 좋지않다.* **❌ log.debug("data="+data)**    * 로그 출력 레벨을 info로 설정해도             해당 코드에 있는 **`"data="+data` 가 실제 실행**이 되어 버린다.    * 결과적으로 **문자 더하기 연산이 발생**한다.* **✔ log.debug("data={}", data)**    * 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않는다.    * 따라서 앞과 같은 의미없는 연산이 발생하지 않는다.<br/>## ⚡️ 로그 사용시 장점```javalog.info("hello");System.out.println("hello");```실무에서는 항상 시스템 콘솔 출력 대신 로그를 사용한다.    시스템 콘솔로 직접 출력하는 것 보다 로그를 사용하면 다음과 같은 장점이 있다.* 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.* 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고,      운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.* 시스템 아웃 콘솔에만 출력하는 것이 아니라, **파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.*** **특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.*** 성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다.# 참고로그에 대해서 더 자세한 내용은 slf4j, logback을 검색해보자.* [SLF4J](http://www.slf4j.org)* [Logback](http://logback.qos.ch)스프링 부트가 제공하는 로그 기능은 다음을 참고하자.* [스프링 log docs](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-bootfeatures.html#boot-features-logging)<br/><br/><br/># 💡 요청 매핑## ⚡️@RequestMapping```java@RestControllerpublic class MappingController {    private Logger log = LoggerFactory.getLogger(getClass());        /**    * 기본 요청    * 둘다 허용 /hello-basic, /hello-basic/    * HTTP 메서드 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE    */    @RequestMapping("/hello-basic")    public String helloBasic() {        log.info("helloBasic");        return "ok";    }}```**@RestController*** `@Controller` 는 **반환 값이 `String` 이면 `View 이름`**으로 인식한다. 그래서 뷰를 찾고 뷰가 랜더링 된다.* `@RestController` 는 반환 값으로 View 를 찾는 것이 아니라, **`HTTP Message Body`에 바로 입력**한다.* `@RestController`는 `@ResponseBody` 와 관련이 있는데, 뒤에서 더 자세 설명한다.**@RequestMapping("/hello-basic")*** **매핑**  * `/hello-basic` URL 호출이 오면 이 메서드가 실행되도록 매핑한다.  * 대부분의 속성을 배열[] 로 제공하므로 다중 설정이 가능하다. `{"/hello-basic", "/hello-go"}`    * ~~URL 끝에 `/` 붙어도 이를 생략한 URL로 매핑해준다.~~      * ~~URL 요청: `/hello-basic` , `/hello-basic/`~~      * ~~매핑: /hello-basic~~> ### **스프링 부트 3.0 이후**> 스프링 부트 3.0 부터는 `/hello-basic` , `/hello-basic/` 는 서로 다른 URL 요청을 사용해야 한다.   > 기존에는 마지막에 있는 `/` (slash)를 제거했지만, 스프링 부트 3.0 부터는 마지막의 `/` (slash)를 유지한다.  > 따라서 다음과 같이 다르게 매핑해서 사용해야 한다.> > 매핑: `/hello-basic` ->  URL요청: `/hello-basic`  > 매핑: `/hello-basic/` -> URL요청: `/hello-basic/`* **HTTP 메서드**  * 일반적으로 `@RequestMapping` 에 특정 메서드를 지정하여 사용한다.    ```java    @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)    public String mappingGetV1() {        log.info("mappingGetV1");        return "ok";    }     ```  만약 여기에 POST 요청을 하면 스프링 MVC는 HTTP 405 상태코드(Method Not Allowed)를 반환한다.  * method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다.  * 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE  * method 속성 또한 배열이 가능하므로 여러 HttpMethod를 지원하게 할 수 있다.<br/><br/>## ⚡️HTTP 메서드 매핑 축약```java@GetMapping(value = "/mapping-get-v2")public String mappingGetV2() {    log.info("mapping-get-v2");    return "ok";}```HTTP 메서드를 축약한 애노테이션을 사용하는 것이 더 직관적이다.           내부를 보면 @RequestMapping 과 method 를 지정해서 사용하는 것을 확인할 수 있다.**편리한 축약 애노테이션 (코드보기)*** @GetMapping* @PostMapping* @PutMapping* @DeleteMapping* @PatchMapping<br/><br/>## ⚡️ PathVariable(경로 변수) 사용```java/** * PathVariable 사용 * 변수명이 같으면 생략 가능 * @PathVariable("userId") String userId -> @PathVariable String userId * */@GetMapping("/mapping/{userId}")public String mappingPathVariable(@PathVariable("userId") String userId) {  log.info("mappingPath userId: {}", userId);  return "ok";}````@RequestMapping`은 URL 경로를 템플릿화 할 수 있는데,     `@PathVariable`을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.`@PathVariable`은 템플릿화된 경로의 값을 가져오는데       쉽게 설명하면 URL 에 입력된 경로 문자열을 변수에 담아 데이터로 활용할 수 있는 것을 의미한다.```java@GetMapping("/mapping/{userId}")public String mappingPath(@PathVariable String userId) {    log.info("mappingPath userId={}", data);    return "ok";}```스프링에서는 `@PathVariable`대상 `{}` 템플릿 이름과 파라미터 이름이 같으면        `@PathVariable`어노테이션의 value 속성 값을 생략할 수 있다.                          **단, `@PathVariable`를 생략하면 이는 @ModelAttribute 로직으로 빠지니 주의하자****예시 - 다중 PathVariable 사용**```java@GetMapping("/mapping/users/{userId}/orders/{orderId}")public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {    log.info("mappingPath userId={}, orderId={}", userId, orderId);    return "ok";}```당연하지만 `@PathVariable`은 다중으로 사용할 수 있다.<br/><br/>## ⚡️ 특정 파라미터 조건 매핑```java@GetMapping(value = "/mapping-param", params = "mode=debug")public String mappingParam() {    log.info("mappingParam");    return "ok";}```특정 파라미터(쿼리 스트링)가 있거나 없는 조건을 추가할 수 있다. 잘 사용하지는 않는다.**파라미터로 추가 매핑*** params="mode",* params="!mode"* params="mode=debug"* params="mode!=debug" (! = )* params = {"mode=debug","data=good"}<br/><br/>## ⚡️특정 헤더 조건 매핑```java@GetMapping(value = "/mapping-header", headers = "mode=debug")public String mappingHeader() {    log.info("mappingHeader");    return "ok";}```파라미터 매핑과 비슷하지만, HTTP 헤더를 사용한다.**특정 헤더로 추가 매핑*** headers="mode",* headers="!mode"* headers="mode=debug"* headers="mode!=debug" (! = )<br/><br/>## ⚡️미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume```java@PostMapping(value = "/mapping-consume", consumes = "application/json")public String mappingConsumes() {    log.info("mappingConsumes");    return "ok";}```**Content-Type 헤더 기반 추가 매핑 Media Type*** consumes="application/json"* consumes="!application/json"* consumes="application/*"* consumes="*\/*"* MediaType.APPLICATION_JSON_VALUEHTTP 요청의 Content-Type 헤더를 기반으로 미디어 타입으로 매핑한다.  만약 맞지 않으면 HTTP 415 상태코드(Unsupported Media Type)을 반환한다.<br/><br/>## ⚡️미디어 타입 조건 매핑 - HTTP 요청 Accept, produce```java@PostMapping(value = "/mapping-produce", produces = "text/html")public String mappingProduces() {    log.info("mappingProduces");    return "ok";}```HTTP 요청의 Accept 헤더를 기반으로 미디어 타입으로 매핑한다.   만약 맞지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환한다.   (클라이언트가 클라이언트에서 받아들일 수 있는 형태를 알려준 것)**Accept 헤더 기반 Media Type*** produces = "text/html"* produces = "!text/html"* produces = "text/*"* produces = "*\/*"예시)       produces = "text/plain"    produces = {"text/plain", "application/*"}     produces = MediaType.TEXT_PLAIN_VALUE      produces = "text/plain;charset=UTF-8"           <br/><br/><br/># 💡 요청 매핑 - API 예시**회원 관리 API*** 회원 목록 조회: `GET /users`* 회원 등록: `POST /users`* 회원 조회: `GET /users/{userId}`* 회원 수정: `PATCH /users/{userId}`* 회원 삭제: `DELETE /users/{userId}````java@RestController@RequestMapping("/mapping/users")public class MappingClassController {     /**     * GET /mapping/users     */     @GetMapping     public String users() {         return "get users";     }     /**     * POST /mapping/users     */     @PostMapping     public String addUser() {         return "post user";     }     /**     * GET /mapping/users/{userId}     */     @GetMapping("/{userId}")     public String findUser(@PathVariable String userId) {         return "get userId=" + userId;     }     /**     * PATCH /mapping/users/{userId}     */     @PatchMapping("/{userId}")     public String updateUser(@PathVariable String userId) {         return "update userId=" + userId;     }     /**     * DELETE /mapping/users/{userId}     */     @DeleteMapping("/{userId}")     public String deleteUser(@PathVariable String userId) {        return "delete userId=" + userId;    }}```**@RequestMapping("/mapping/users")**    클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용한다.* 회원 목록 조회: `GET /mapping/users`* 회원 등록: `POST /mapping/users`* 회원 조회: `GET /mapping/users/id1`* 회원 수정: `PATCH /mapping/users/id1`* 회원 삭제: `DELETE /mapping/users/id1`매핑 방법을 이해했으니, 이제부터 HTTP 요청이 보내는 데이터들을 스프링 MVC로 어떻게 조회하는지 알아보자.<br/><br/><br/># 💡HTTP 요청 - 기본, 헤더 조회어노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다.    이번에는 HTTP 헤더 정보를 조회하는 방법을 알아보고자 한다.```java@Slf4j@RestControllerpublic class RequestHeaderController {    @RequestMapping("/headers")    public String headers(            HttpServletRequest request,            HttpServletResponse response,            HttpMethod httpMethod,            Locale locale,            @RequestHeader MultiValueMap<String, String> headerMap,            @RequestHeader("host") String host,            @CookieValue(value = "myCookie", required = false) String cookie) {                log.info("request={}", request);        log.info("response={}", response);        log.info("httpMethod={}", httpMethod);        log.info("locale={}", locale);        log.info("headerMap={}", headerMap);        log.info("header host={}", host);        log.info("myCookie={}", cookie);                return "ok";    }}```  * **HttpServletRequest**     Servlet에서 제공하는 HttpServletRequest 객체* **HttpServletResponse**        Servlet에서 제공하는 HttpServletResponse 객체* **HttpMethod**        `org.springframework.http.HttpMethod`         HTTP 메서드(GET/POST 등등)를 조회할 때 사용하는 객체* **Locale**      Locale(지역) 정보를 조회하고 주로 국제화할 때 사용한다.* **@RequestHeader MultiValueMap<String, String> headerMap**        모든 HTTP 헤더를 Key와 다중 Value인, MultiValueMap 형식으로 조회한다.* **@RequestHeader("host") String host**        특정 HTTP 헤더를 조회한다.  * 필수 값 여부: required  * 기본 값 속성: defaultValue* **@CookieValue(value = "myCookie", required = false) String cookie**            특정 쿠키를 조회한다.  * 필수 값 여부: required  * 기본 값: defaultValue* **MultiValueMap**     MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.        HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.  ```http  keyA=value1&keyA=value2  ```  ```java  MultiValueMap<String, String> map = new LinkedMultiValueMap();  map.add("keyA", "value1");  map.add("keyA", "value2");    //[value1,value2]  List<String> values = map.get("keyA");  ```**참고*** @Conroller 의 사용 가능한 파라미터 목록은 다음 [공식 메뉴얼](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-annarguments)에서 확인할 수 있다.* @Conroller 의 사용 가능한 응답 값 목록은 다음 [공식 메뉴얼](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-annreturn-types)에서 확인할 수 있다.<br/><br/><br/># 💡HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다.**GET - 쿼리 파라미터*** `/url?username=hello&age=20`* 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달* 예) 검색, 필터, 페이징등에서 많이 사용하는 방식**POST - HTML Form*** `content-type: application/x-www-form-urlencoded`* 메시지 바디에 쿼리 파리미터 형식으로 전달 `username=hello&age=20`* 예) 회원 가입, 상품 주문, HTML Form 사용**HTTP message body에 데이터를 직접 담아서 요청*** HTTP API에서 주로 사용, `JSON`, `XML`, `TEXT`* 데이터 형식은 주로 JSON 사용* `POST`, `PUT`, `PATCH`**요청 파라미터 - 쿼리 파라미터, HTML Form**    `HttpServletRequest` 의 `request.getParameter()`를 사용하면 다음 두가지 요청 파라미터를 조회할 수 있다.* GET 쿼리 파리미터 전송 방식* POST HTML Form 전송 방식파라미터 바인딩의 대상은 `Get`/`POST form` 두 요청에 한해서고      만약, **Post Json 방식으로 요청을 보낸다면 파라미터 바인딩의 대상이 되지 않는다.**```httpPOST /request-param ...content-type: application/x-www-form-urlencodedusername=hello&age=20```  `GET 쿼리 파리미터` 전송 방식이든, `POST HTML Form` 전송 방식이든         사실상 둘다 형식이 같으므로 구분없이 조회할 수 있다.       **이것을 간단히 요청 파라미터(request parameter) 조회라 한다.**```java@Slf4j@Controllerpublic class RequestParamController {    /**    * 반환 타입이 없으면서 이렇게 응답에 값을 직접 집어넣으면, view 조회X    */    @RequestMapping("/request-param-v1")    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {        String username = request.getParameter("username");        int age = Integer.parseInt(request.getParameter("age"));        log.info("username={}, age={}", username, age);        response.getWriter().write("ok");    }}```위 코드를 테스트하기 위한 html 을 작성해보면 아래와 같다.     참고로 **정적 리소스**는 `/resources/static` 아래에 두면 스프링 부트가 자동으로 인식한다.```html<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>Title</title></head><body>    <form action="/request-param-v1" method="post">        username: <input type="text" name="username" />        age: <input type="text" name="age" />        <button type="submit">전송</button>    </form></body></html>```> ### **참고**   > Jar 를 사용하면 webapp 경로를 사용할 수 없다.      > 이제부터 정적 리소스도 클래스 경로에 함께 포함해야 한다.<br/><br/><br/># 💡HTTP 요청 파라미터 - @RequestParam> `@RequestParam`을 사용하면 요청 파라미터를 매우 편리하게 사용할 수 있다.         > `@RequestParam(value="")`에 파라미터 이름(key)을 넣으면 해당 데이터를 바인딩 할 수 있다.<br/>## ⚡️일반적인 사용법```java @ResponseBody@RequestMapping("/request-param-v2")public String requestParamV2(@RequestParam("username") String memberName, @RequestParam("age") int memberAge) {    log.info("username={}, age={}", memberName, memberAge);    return "ok";}```* @RequestParam 사용 : 파라미터 이름으로 바인딩* @ResponseBody 추가 : View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력**동일 이름 생략 전략, 기본 타입이면 @RequestParam 생략 전략이 있지만 Spring Boot 3.2 부터 Java Compiler 에 -parameters 옵션을 넣어주어야 애노테이션에 적는 이름을 생략할 수 있다.  웬만하면 애노테이션에 이름을 생략하지 않고 이름을 항상 적어준다.**<details><summary>동일 이름 생략 전략, 기본 타입이면 @RequestParam 생략 전략</summary><div markdown="1">## 동일 이름 생략 전략```java@ResponseBody@RequestMapping("/request-param-v3")public String requestParamV3(@RequestParam String username, @RequestParam int age) {    log.info("username={}, age={}", username, age);    return "ok";}```HTTP 파라미터 이름이 변수 이름과 같으면      `@RequestParam(name="xx")`에서 **name/value 속성을 생략한 `@RequestParam`만 기입 가능하다.**## 기본 타입이면 @RequestParam 생략 전략```java@ResponseBody@RequestMapping("/request-param-v4")public String requestParamV4(String username, int age) { log.info("username={}, age={}", username, age); return "ok";}```HTTP 파라미터 이름이 변수 이름과 같고, 파라미터 타입이 String , int , Integer 등의 단순 타입이면          **@RequestParam 도 생략 가능하다.(기본 컨버터가 지원해주는 타입이여서 그렇다.)****주의*** @RequestParam 애노테이션을 생략하면 스프링 MVC는 내부에서 required=false 를 적용한다.**참고*** 이렇게 애노테이션을 완전히 생략해도 되는데, 너무 없는 것도 약간 과하다는 주관적 생각이 있다.* @RequestParam 이 있으면 명확하게 요청 파리미터에서 데이터를 읽는다는 것을 알 수 있다.</div></details>### ⁉️ 주의! 스프링 부트 3.2 파라미터 이름 인식 문제 다음 예외가 발생하면 해당 내용을 참고하자. ⁉️**발생하는 예외** ```java.lang.IllegalArgumentException: Name for argument of type [java.lang.String]not specified, and parameter name information not found in class file either.```스프링 부트 3.2부터 자바 컴파일러에 -parameters 옵션을 넣어주어야 애노테이션에 적는 이름을 생략할 수 있다. 주로 다음 두 애노테이션에서 문제가 발생한다.`@RequestParam` , `@PathVariable`**해결 방안1(권장)**  애노테이션에 이름을 생략하지 않고 다음과 같이 이름을 항상 적어준다. **이 방법을 권장한다.**- `@RequestParam("username") String username` `@PathVariable("userId") String userId`**해결 방안2**  컴파일 시점에 -parameters 옵션 적용1. IntelliJ IDEA에서 File Settings를 연다. (Mac은 IntelliJ IDEA Settings)2. Build, Execution, Deployment → Compiler → Java Compiler로 이동한다.3. Additional command line parameters라는 항목에 다음을 추가한다.   `-parameters`4. out 폴더를 삭제하고 다시 실행한다. 꼭 out 폴더를 삭제해야 다시 컴파일이 일어난다.**해결 방안3**  Gradle을 사용해서 빌드하고 실행한다.**문제 원인**  참고로 이 문제는 `Build, Execution, Deployment -> Build Tools -> Gradle` 에서 _Build and run using_ 를 **`IntelliJ IDEA`로 선택한 경우에만 발생**한다.   Gradle로 선택한 경우에는 Gradle이 컴파일 시점에 해당 옵션을 자동으로 적용해준다.   자바를 컴파일할 때 매개변수 이름을 읽을 수 있도록 남겨두어야 사용할 수 있다. 컴파일 시점에 `-parameters` 옵션 을 사용하면 매개변수 이름을 사용할 수 있게 남겨둔다.   스프링 부트 3.2 전까지는 바이트코드를 파싱해서 매개변수 이름을 추론하려고 시도했다. 하지만 스프링 부트 3.2 부터 는 이런 시도를 하지 않는다.<br/><br/>## ⚡️파라미터 필수 여부 - @RequestParam(required = true)```java @ResponseBody@RequestMapping("/request-param-required")public String requestParamRequired(@RequestParam(required = true) String username,                                   @RequestParam(required = false) Integer age) {    log.info("username={}, age={}", username, age);    return "ok";}````@RequestParam`의 required 속성을 이용해 필수로 존재해야할 파라미터를 정할 수 있다.         `@RequestParam`선언을 한다면 기본값은 `(required = true)`이며 없으면 400 예외가 발생시킨다.* 필수 : @RequestParam(required = true)* 선택 : @RequestParam(required = false)**주의 사항*** `/request-param?username=`  * 빈문자로 에러 없이 통과* `/request-param 요청`, `@RequestParam(required = false) int age`  * required = false 임에도 값을 안 넣으면 에러가 발생한다.(500 예외 발생)  * null을 int에 입력하는 것은 불가능하기 때문이다.  * 따라서 null 을 받을 수 있는 Integer 로 변경하거나, 또는 다음에 나오는 defaultValue 사용해야 한다.<br/><br/>## ⚡️기본 값 적용 - @RequestParam(defaultValue = "guest")```java@ResponseBody@RequestMapping("/request-param-default")public String requestParamDefault(@RequestParam(required = true, defaultValue = "guest") String username,                                  @RequestParam(required = false, defaultValue = "-1") int age) { log.info("username={}, age={}", username, age); return "ok";}```파라미터에 값이 없는 경우 defaultValue 를 사용하면 기본 값을 적용할 수 있다.      이미 기본 값이 있기 때문에 required 는 사실상 의미가 없다.**참고*** `/request-param?username=`        defaultValue는 빈 문자의 경우에도 적용이 된다.<br/><br/>## ⚡️파라미터를 Map으로 조회하기 - requestParamMap```java@ResponseBody@RequestMapping("/request-param-map")public String requestParamMap(@RequestParam Map<String, Object> paramMap) {    log.info("username={}, age={}", paramMap.get("username"),    paramMap.get("age"));    return "ok";}```파라미터를 `Map`, `MultiValueMap`으로 조회할 수 있다.**@RequestParam Map, MultiValueMap*** `Map(key=value)`* `MultiValueMap(key=[value1, value2, ...] ex) (key=userIds, value=[id1, id2])`파라미터의 값이 1개가 확실하다면 `Map` 을 사용해도 되지만, 그렇지 않다면 `MultiValueMap` 을 사용하자.<br/><br/><br/># 💡HTTP 요청 파라미터 - @ModelAttribute실제 개발을 하면 **요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주어야 한다.**        **스프링은 이 과정을 완전히 자동화해주는 @ModelAttribute 기능을 제공한다.****파라미터를 바인딩 받을 객체**```java@Datapublic class HelloData {    private String username;    private int age;}```  **롬복 @Data**   `@Getter` , `@Setter` , `@ToString` , `@EqualsAndHashCode` , `@RequiredArgsConstructor` 자동 적용<br/><br/>## ⚡️@ModelAttribute 적용 - modelAttributeV1```java@ResponseBody@RequestMapping("/model-attribute-v1")public String modelAttributeV1(@ModelAttribute HelloData helloData) {    log.info("username={}, age={}", helloData.getUsername(),    helloData.getAge());    return "ok";}```스프링MVC는 `@ModelAttribute`가 있으면 **요청 파라미터에 알맞는 객체를 생성한다.**      단, `주입`을 기반으로 동작하기에 **생성자 or setter가 필수로 존재해야한다.****동작 과정**1. 요청 파라미터의 이름으로 HelloData 객체의 프로퍼티를 찾는다.2. 해당 프로퍼티의 `생성자` or `setter`를 호출해서 파라미터의 값을 입력(바인딩) 한다.**바인딩 오류**   `age=abc` 처럼 숫자가 들어가야 할 곳에 문자를 넣으면 `BindException` 이 발생한다.      이런 바인딩 오류를 처리하는 방법은 검증 부분에서 다룬다.**참고**      `model.addAttribute(helloData)` 코드도 함께 자동 적용되어 자동으로 모델을 등록한다.<br/>## ⚡️@ModelAttribute 생략 - modelAttributeV2```java@ResponseBody@RequestMapping("/model-attribute-v2")public String modelAttributeV2(HelloData helloData) {    log.info("username={}, age={}", helloData.getUsername(),    helloData.getAge());    return "ok";}````@ModelAttribute`는 생략할 수 있다.그런데 @RequestParam 도 생략할 수 있으니 혼란이 발생할 수 있기에    스프링은 어노테이션 생략시 다음과 같은 규칙을 적용한다.* **@RequestParam :** String, int, Integer와 같은 문자열, 프리미티브, 래퍼 클래스* **@ModelAttribute :** 나머지(argument resolver 로 지정해둔 타입 외의 레퍼 클래스)  <br/><br/><br/># 💡HTTP 요청 메시지 - 단순 텍스트> HTTP message body에 데이터를 직접 담아서 요청HTTP API에서 **데이터 형식은 `JSON`, `XML`, `TEXT`이 있으며 주로 JSON 사용한다.**             HTTP message body에 데이터를 담는 **HTTP 메서드는 `POST`, `PUT`, `PATCH` 이다.(GET도 가능하지만 거의 사용 X)****주의 사항**    요청 파라미터와 다르게,    **HTTP 메시지 바디를 통해 데이터가 직접 데이터가 넘어오는 경우는 @RequestParam , @ModelAttribute 를 사용할 수 없다.**       (물론 HTML Form 형식으로 전달되는 경우는 요청 파라미터로 인정된다.(Post-HTML/FORM))<br/>## ⚡️기본 HttpServletRequest> 먼저 가장 단순한 텍스트 메시지를 HTTP 메시지 바디에 담아서 전송하고, 읽어보자.HttpServletRequest의 `getInputStream()`를 이용하면 InputStream객체를 얻을 수 있다.   **HTTP 메시지 바디의 데이터를 `InputStream` 을 사용해서 직접 읽을 수 있다.**```java@Slf4j@Controllerpublic class RequestBodyStringController {     @PostMapping("/request-body-string-v1")     public void requestBodyString(HttpServletRequest request, HttpServletResponse response) throws IOException {         ServletInputStream inputStream = request.getInputStream();         String messageBody = StreamUtils.copyToString(inputStream,         StandardCharsets.UTF_8);         log.info("messageBody={}", messageBody);         response.getWriter().write("ok");     }}```  <br/><br/>## ⚡️Input, Output 스트림, Reader```java@PostMapping("/request-body-string-v2")public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException {    String messageBody = StreamUtils.copyToString(inputStream,    StandardCharsets.UTF_8);    log.info("messageBody={}", messageBody);    responseWriter.write("ok");}```스프링 MVC는 다음 파라미터를 지원한다.* **InputStream(Reader):** HTTP 요청 메시지 바디의 내용을 직접 조회* **OutputStream(Writer):** HTTP 응답 메시지의 바디에 직접 결과 출력<br/><br/>## ⚡️HttpEntity```java @PostMapping("/request-body-string-v3")public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) {    String messageBody = httpEntity.getBody();    log.info("messageBody={}", messageBody);    return new HttpEntity<>("ok");}```스프링 MVC는 다음 파라미터를 지원한다.**HttpEntity: HTTP header, body 정보를 편리하게 조회*** 메시지 바디 정보를 직접 조회  * 요청 파라미터를 조회하는 기능과 관계 없음  * `@RequestParam` ❌, `@ModelAttribute` ❌  * 헤더 정보 포함 가능* 메시지 바디 정보 직접 반환  * HttpEntity는 응답에서도 사용 가능  * `view 렌더링` ❌* `HttpMessageConverter` 사용 -> `StringHttpMessageConverter` 적용**HttpEntity를 상속받은 RequestEntity, ResponseEntity**     HttpEntity 를 상속받은 다음 객체들도 같은 기능을 제공한다.* **RequestEntity**        HttpMethod, url 정보가 추가, 요청에서 사용    ```java    public HttpEntity<String> requestBodyStringV3(RequestEntity<String> requestEntity) {    ```  * **ResponseEntity**       HTTP 상태 코드 설정 가능, 응답에서 사용    ```java    return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.OK)       ```> ### **참고**   > 스프링MVC 내부에서 HTTP 메시지 바디를 읽어서 문자나 객체로 변환해서 전달해주는데,       > 이때 HTTP 메시지 컨버터(`HttpMessageConverter`)라는 기능을 사용한다.<br/><br/>## ⚡️@RequestBody ✅```java@ResponseBody@PostMapping("/request-body-string-v4")public String requestBodyStringV4(@RequestBody String messageBody) {    log.info("messageBody={}", messageBody);    return "ok";}```**`@RequestBody`*** 메시지 바디 정보를 직접 조회(**@RequestParam ❌**, **@ModelAttribute ❌**)* 메시지 바디 정보만 가져오기에 헤더 정보가 필요하다면 `@RequestHeader`를 사용해야 한다.(`HttpEntity`를 사용하거나)* `HttpMessageConverter` 사용 -> `StringHttpMessageConverter` 적용**`@ResponseBody`*** 메시지 바디 정보 직접 반환(**view 조회 ❌**)* `HttpMessageConverter` 사용 -> `StringHttpMessageConverter` 적용## **⚡️정리 - 요청 파라미터 vs HTTP 메시지 바디✅*** **요청 파라미터를 조회하는 기능:** @RequestParam , @ModelAttribute* **HTTP 메시지 바디를 직접 조회하는 기능:** @RequestBody<br/><br/><br/># 💡HTTP 요청 메시지 - JSON```jsoncontent-type: application/json        {"username":"hello", "age":20}```<br/>## ⚡️기본> 기존 서블릿에서 사용했던 방식과 비슷하게 시작해보자.```java@Slf4j@Controllerpublic class RequestBodyJsonController {    private ObjectMapper objectMapper = new ObjectMapper();        @PostMapping("/request-body-json-v1")    public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) throws IOException {        ServletInputStream inputStream = request.getInputStream();        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);        log.info("messageBody={}", messageBody);                HelloData data = objectMapper.readValue(messageBody, HelloData.class);        log.info("username={}, age={}", data.getUsername(), data.getAge());                response.getWriter().write("ok");    }}```HttpServletRequest를 사용해서 직접 HTTP 메시지 바디에서 데이터를 읽어와서, 문자로 변환한다.    문자로 된 JSON 데이터를 Jackson 라이브러리인 objectMapper 를 사용해서 자바 객체로 변환한다.<br/><br/>## ⚡️@RequestBody 문자 변환```java@ResponseBody@PostMapping("/request-body-json-v2")public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException {    HelloData data = objectMapper.readValue(messageBody, HelloData.class);    log.info("username={}, age={}", data.getUsername(), data.getAge());    return "ok";}````@RequestBody`는 문자로 된 JSON 데이터인 messageBody 를 objectMapper 를 통해서 자바 객체로 변환한다.    위 예시에서는 문자로 된 JSON 데이터를 별다른 컨버터/매핑없이 String으로만 변환했다.**@RequestBody*** HttpMessageConverter 사용 -> StringHttpMessageConverter 적용**@ResponseBody*** 메시지 바디 정보 직접 반환(view 조회X)* HttpMessageConverter 사용 -> StringHttpMessageConverter 적용<br/><br/>## ⚡️`@RequestBody` 객체 변환```java@ResponseBody@PostMapping("/request-body-json-v3")public String requestBodyJsonV3(@RequestBody HelloData data) {    log.info("username={}, age={}", data.getUsername(), data.getAge());    return "ok";}```**@RequestBody*** @RequestBody 에 직접 만든 객체를 지정할 수도 있다.(getter/setter 역직렬화로 동작 -> 문자열에서 객체 생성하는 작업)* @RequestBody는 생략 불가능하다. `@ModelAttribute`가 적용되어 버리기 때문이다.* HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter (contenttype: application/json)HttpEntity, @RequestBody 를 사용하면      `HttpMessageConverter`가 **HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환**해준다.        `HttpMessageConverter`는 **문자열 뿐만 아니라 JSON도 객체로 변환해준다.(역직렬화 방식으로)**        `역직렬화 방식`은 **기본 생성자랑 getter/setter 둘 중 하나가 필수적으로 존재해야한다.**<br/>**@RequestBody는 생략 불가능**             파라미터에 `@ModelAttribute` , `@RequestParam` 생략시 다음과 같은 규칙을 적용한다.* **@RequestParam :** String , int , Integer 같은 단순 타입* **@ModelAttribute :** 나머지 (argument resolver 로 지정해둔 타입 외)따라서 `@RequestBody`를 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터를 처리하게 된다.       즉, `@RequestBody`를 생략하면 `@ModelAttribute`나 `@RequestParam`가 적용되어버린다.<br/>> ### **주의**   > 객체 변환시에는 HTTP 요청시에 content-type이 application/json인지 확인해야 한다.     > 그래야 JSON을 처리할 수 있는 HTTP 메시지 컨버터가 실행된다.            > 물론 앞서 배운 것과 같이 HttpEntity를 사용해도 된다.<br/><br/>## ⚡️HttpEntity```java@ResponseBody@PostMapping("/request-body-json-v4")public String requestBodyJsonV4(HttpEntity<HelloData> httpEntity) { HelloData data = httpEntity.getBody(); log.info("username={}, age={}", data.getUsername(), data.getAge()); return "ok";}```   `HttpEntity`를 이용해서 요청 파라미터를 처리할 수 있다.        이전에 언급했듯이 Http 바디는 물론 헤더에 관한 처리도 할 수 있다.```java@ResponseBody@PostMapping("/request-body-json-v4")public String requestBodyJsonV4(Request<HelloData> httpEntity) { HelloData data = httpEntity.getBody(); log.info("username={}, age={}", data.getUsername(), data.getAge()); return "ok";}```   Http 바디에 대해서만 작업을 하려면 `Request`를 이용해서 요청 파라미터를 처리할 수 있다.<br/><br/>## ⚡️@ResponseBody```java@ResponseBody@PostMapping("/request-body-json-v5")public HelloData requestBodyJsonV5(@RequestBody HelloData data) {    log.info("username={}, age={}", data.getUsername(), data.getAge());    return data;}```      위 코드는 사용자 정의 객체를 반환하는 형태로 구현되어 있다.**@ResponseBody**     응답의 경우에도 @ResponseBody 를 사용하면 해당 객체를 HTTP 메시지 바디에 직접 넣어줄 수 있다.    물론 이 경우에도 HttpEntity 를 사용해도 된다.**@RequestBody 요청*** `JSON 요청` -> `HTTP 메시지` -> `컨버터 객체`**@ResponseBody 응답*** `객체` -> `HTTP 메시지 컨버터` -> `JSON 응답`<br/><br/><br/># 💡HTTP 응답 - 정적 리소스, 뷰 템플릿스프링(서버)에서 응답 데이터를 만드는 방법은 크게 3가지이다.* **정적 리소스**    웹 브라우저에 정적인 HTML, css, js을 제공할 때는, 정적 리소스를 사용한다.* **뷰 템플릿 사용**      웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.* **HTTP 메시지 사용**     HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로,     HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.<br/>## ⚡️정적 리소스> 정적 리소스는 해당 파일을 변경 없이 그대로 서비스하는 것스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공한다.* **src/main/resources 하위** : `/static` , `/public` , `/resources` , `/META-INF/resources``src/main/resources`는 리소스를 보관하는 곳이고, **또 클래스패스의 시작 경로이다.**      따라서 **`src/main/resources`에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.****정적 리소스 반환**   `src/main/resources/static` 경로에 파일이 들어있으면 정적 리소스를 반환해준다.     즉, `src/main/resources/static/basic/hello-form.html`을 입력하면 `hello-form.html`를 바로 반환한다.            사실 정적 리소스 반환이란, **Controller 를 통해 매핑되지 않은 경로로 데이터 요청시 바로 리소스를 반환하는 것을 말한다.**<br/><br/>## 뷰 템플릿> 뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.스프링 부트는 기본 뷰 템플릿 경로를 제공한다.        **뷰 템플릿 경로 :** `src/main/resources/templates`**src/main/resources/templates/response/hello.html**```html<!DOCTYPE html><html xmlns:th="http://www.thymeleaf.org"><head>    <meta charset="UTF-8">    <title>Title</title></head><body>    <p th:text="${data}">empty</p></body></html>```**ResponseViewController - 뷰 템플릿을 호출하는 컨트롤러**```java@Controllerpublic class ResponseViewController {          @RequestMapping("/response-view-v1")     public ModelAndView responseViewV1() {         ModelAndView mav = new ModelAndView("response/hello").addObject("data", "hello!");         return mav;     }          @RequestMapping("/response-view-v2")     public String responseViewV2(Model model) {         model.addAttribute("data", "hello!!");         return "response/hello";     }          @RequestMapping("/response/hello")     public void responseViewV3(Model model) {         model.addAttribute("data", "hello!!");     }}```        **String을 반환하는 경우 - View or HTTP 메시지*** `@ResponseBody`가 없으면 `response/hello`로 ViewResolver 가 실행되어서 뷰를 찾고, 렌더링 한다.* `@ResponseBody`가 있으면 **ViewResolver 를 실행하지 않고, HTTP Message Body 에 직접 `response/hello`라는 문자가 입력된다.****Void를 반환하는 경우*** `@Controller`를 사용하고 `HttpServletResponse` , `OutputStream(Writer)`과 같은       **HTTP 메시지 바디를 처리하는 파라미터가 없으면 요청 URL을 참고해서 논리 뷰 이름으로 사용한다.**  * **요청 URL:** `/response/hello`  * **실행 URL:** `templates/response/hello.html`* 참고로 이 방식은 명시성이 너무 떨어지고 딱 맞는 경우도 많이 없어서 권장하지 않는다.> ### 참고: HTTP 메시지> `@ResponseBody`, `HttpEntity`를 사용하면       > 뷰 템플릿을 사용이 아닌, **HTTP 메시지 바디에 직접 응답 데이터를 출력할 수 있다.**<br/><br/>**Thymeleaf 스프링 부트 설정**```gradle// build.gradle  implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'```      스프링 부트가 자동으로 ThymeleafViewResolver 와 필요한 스프링 빈들을 등록한다.      그리고 **properties 설정**을 하는데 아래 설정은 기본 값으로 변경이 필요할 때 바꾸면 된다.```properties# application.propertiesspring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html```  **참고**       스프링 부트의 타임리프 관련 추가 설정은 다음 [공식 사이트](https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-applicationproperties.html#common-application-properties-templating)를 참고하자. (페이지 안에서 thymeleaf 검색)<br/><br/><br/># 💡HTTP 응답 - HTTP API, 메시지 바디에 직접 입력`HTTP API`를 제공하는 경우에는 **HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.*** **text/plain 등등 :** StringHttpMessageConverter* **application/json :** MappingJackson2HttpMessageConverter<br/>## ⚡️1. HttpServletResponse```java@Slf4j@RestControllerpublic class ResponseBodyController {      @GetMapping("/response-body-string-v1")     public void responseBodyV1(HttpServletResponse response) throws IOException {         response.getWriter().write("ok");     }}````HttpServletResponse` 객체를 통해서 HTTP 메시지 바디에 직접 ok 응답 메시지를 전달한다.<br/><br/>## ⚡️2. ResponseEntity(HttpEntity)```java@Slf4j@RestControllerpublic class ResponseBodyController {      @GetMapping("/response-body-string-v2")     public ResponseEntity<String> responseBodyV2() {         return new ResponseEntity<>("ok", HttpStatus.OK);     }}```HttpEntity는 HTTP 메시지의 헤더, 바디 정보를 가지고 있다.      ResponseEntity는 HttpEntity 를 상속 받고 있으며 추가적으로 HTTP 응답 코드를 설정할 수 있다.         만약, HttpStatus.CREATED 로 변경하면 201 응답이 나가는 것을 확인할 수 있다.<br/><br/>## ⚡️3. @ResponseBody```java@Slf4j@RestControllerpublic class ResponseBodyController {      @ResponseBody     @GetMapping("/response-body-string-v3")     public String responseBodyV3() {         return "ok";     }}```@ResponseBody 를 사용하면 view를 사용하지 않고,       HTTP 메시지 컨버터를 통해서 HTTP 메시지를 직접 입력할 수 있다.<br/><br/>## ⚡️4. ResponseEntity 객체 반환```java@Slf4j@RestControllerpublic class ResponseBodyController {     @GetMapping("/response-body-json-v1")     public ResponseEntity<HelloData> responseBodyJsonV1() {         HelloData helloData = new HelloData();         helloData.setUsername("userA");         helloData.setAge(20);         return new ResponseEntity<>(helloData, HttpStatus.OK);     }     } ```ResponseEntity를 반환하며 HTTP 메시지 컨버터를 통해서 JSON 형식으로 변환되어서 반환된다.<br/><br/>## ⚡️5. 일반 객체 반환 및 @ResponseStatus```java@Slf4j@RestControllerpublic class ResponseBodyController {     @ResponseStatus(HttpStatus.OK)     @ResponseBody     @GetMapping("/response-body-json-v2")     public HelloData responseBodyJsonV2() {         HelloData helloData = new HelloData();         helloData.setUsername("userA");         helloData.setAge(20);         return helloData;     }}```ResponseEntity는 HTTP 응답 코드를 설정할 수 있는데,             **일반  객체에 @ResponseBody를 사용하면 이런 것을 설정하기 까다롭다.**              이럴 때, `@ResponseStatus(HttpStatus.OK)` 어노테이션을 사용하면 응답 코드도 설정할 수 있다.물론 어노테이션이기 때문에 응답 코드를 동적으로 변경할 수는 없다.        프로그램 조건에 따라서 동적으로 변경하려면 ResponseEntity 를 사용하면 된다.**@RequestBody 요청*** `JSON 요청` -> `HTTP 메시지` -> `컨버터 객체`**@ResponseBody 응답*** `객체` -> `HTTP 메시지 컨버터` -> `JSON 응답`**@RestController**    ```java@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController {    @AliasFor(        annotation = Controller.class    )    String value() default "";}```@Controller 대신에 @RestController 애노테이션을 사용하면,     해당 컨트롤러에 모두 @ResponseBody 가 적용되는 효과가 있다.     따라서 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 데이터를 입력한다.       이름 그대로 Rest API(HTTP API)를 만들 때 사용하는 컨트롤러이다.     참고로 @ResponseBody 는 클래스 레벨에 두면 전체에 메서드에 적용되는데        **`@RestController` 어노테이션 안에 `@ResponseBody` 가 적용되어 있다.**    <br/><br/><br/># 💡HttpMessageConverter뷰 템플릿으로 HTML을 생성해서 응답하는 것이 아니라,    HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.<br/>## ⚡️@ResponseBody 사용 원리![http-converter](https://user-images.githubusercontent.com/50267433/128208586-83a1086f-a38d-4851-961d-068008d77fcb.PNG)**@ResponseBody**          `@ResponseBody`는 핸들러로부터 반환된 데이터를 `Http body`에 문자로 반환을 한다.              이 과정에서 **데이터를 `Http body`에 넣기 위해 HttpMessageConverter 구현체를 사용한다.*** **기본 문자처리:** `StringHttpMessageConverter`* **기본 객체처리:** `MappingJackson2HttpMessageConverter`* **byte 처리 및 기타 등등:** `HttpMessageConverter`(사실 가장 기본)> **참고**   > 응답의 경우 `클라이언트의 HTTP Accept`헤더와 `서버의 컨트롤러 반환 타입 정보`,    > 이 둘을 조합해서 `HttpMessageConverter`가 선택된다.**스프링 MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.*** **HTTP 요청 :** `@RequestBody`, `HttpEntity(RequestEntity)`* **HTTP 응답 :** `@ResponseBody`, `HttpEntity(ResponseEntity)`<br/><br/>## ⚡️ HttpMessageConverter interface**HttpMessageConverter**```javapackage org.springframework.http.converter;public interface HttpMessageConverter<T> {    boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);    boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);    List<MediaType> getSupportedMediaTypes();        T read(Class<? extends T> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;        void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;}```    HTTP 메시지 컨버터는 `HTTP 요청`, `HTTP 응답` 두 곳에서 모두 사용된다.* **canRead()** , **canWrite()** : 메시지 컨버터가 해당 `클래스`, `미디어타입`을 지원하는지 체크* **read()** , **write()** : 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능**스프링 부트 기본 메시지 컨버터**|우선순위|컨버터 종류|   |-------|----------|   |0|ByteArrayHttpMessageConverter||1|StringHttpMessageConverter||2|MappingJackson2HttpMessageConverter|스프링 부트는 다양한 메시지 컨버터를 제공하는데,     **`대상 클래스 타입`과 `미디어 타입` 둘을 체크해서 사용 여부를 결정한다.**          만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다.<br/><br/>### ByteArrayHttpMessageConverter> byte[] 데이터를 처리한다.* **클래스 타입:** `byte[]`* **미디어타입:** `*/*`👉 요청 예) `@RequestBody byte[] data`       👉 응답 예) `@ResponseBody return byte[]` / 쓰기 미디어타입 `application/octet-stream`<br/>### StringHttpMessageConverter> String 문자로 데이터를 처리한다.* **클래스 타입:** `String`* **미디어타입:** `*/*`👉 요청 예) `@RequestBody String data`      👉 응답 예) `@ResponseBody return "ok"` / 쓰기 미디어타입 `text/plain`<br/>### MappingJackson2HttpMessageConverter> application/json* **클래스 타입:** `객체 또는 HashMap`* **미디어타입:** `application/json 관련`👉 요청 예) `@RequestBody HelloData data`      👉 응답 예) `@ResponseBody return helloData` / 쓰기 미디어타입 `application/json` 관련<br/><br/>## ⚡️예시**StringHttpMessageConverter**```httpcontent-type: application/json``````java@RequestMappingvoid hello(@RequetsBody String data) {}```**MappingJackson2HttpMessageConverter**```httpcontent-type: application/json``````java@RequestMappingvoid hello(@RequetsBody HelloData data) {}```**?(못참음 - 에러) -> Exception 발생**```httpcontent-type: text/html``````java  @RequestMappingvoid hello(@RequetsBody HelloData data) {}```**HTTP 요청 데이터 읽기**1. HTTP 요청이 오고, 컨트롤러에서 `@RequestBody`, `HttpEntity` 파라미터를 사용한다.2. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 `canRead()`를 호출한다.  * **대상 클래스 타입을 지원하는가.**    * 예) @RequestBody 의 대상 클래스 ( `byte[]` , `String` , `HelloData` )  * **HTTP 요청의 `Content-Type` 미디어 타입을 지원하는가.**    * 예) `text/plain` , `application/json` , `*/*`3. `canRead()` 조건을 만족하면 `read()` 를 호출해서 객체 생성하고, 반환한다.**HTTP 응답 데이터 생성**1. 컨트롤러에서 `@ResponseBody` , `HttpEntity`로 값이 반환된다.2. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 `canWrite()`를 호출한다.  * **대상 클래스 타입을 지원하는가.**    * 예) return의 대상 클래스 ( `byte[]` , `String` , `HelloData` )  * **HTTP 요청의 `Accept` 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces )**    * 예) `text/plain` , `application/json` , `*/*`3. `canWrite()` 조건을 만족하면 `write()` 를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.<br/><br/><br/>