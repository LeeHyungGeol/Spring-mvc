# 스프링 MVC - 기본 기능<br/>## 목차- 로깅 - SLF4J, Logback- 요청 매핑- 요청 매핑 - API 예시- HTTP 요청 - 기본, 헤더 조회- HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form<br/><br/><br/># 💡로깅 > 운영 시스템에서는, 일반적인 콘솔 출력(sout) 대신 **로깅 라이브러리**를 사용해서 **로그를 출력**한다.<br/>## ⚡️ 로깅 라이브러리 - SLF4J, Logback스프링 부트는 기본적으로 `spring-boot-starter-logging` 라이브러리를 제공한다.**스프링 부트 로깅 라이브러리*** SLF4J - http://www.slf4j.org* Logback - http://logback.qos.ch`SLF4J`는 다양한 로깅 라이브러리를 사용할 수 있도록 정의된 **통합 로그 인터페이스다.**                  구현체로는 `Logback`, `Log4J`, `Log4J2` 등등이 있으며 **`Spring Boot` 는 `Logback`를 지원해준다.**              **즉, 스프링부트는 SLF4J 인터페이스 및 LogBack 구현체를 제공해 로깅 기능을 지원해준다는 의미이다.**<br/>## ⚡️ 로그 선언**방법1**```javaprivate Logger log = LoggerFactory.getLogger(getClass());```**방법2**```javaprivate static final Logger log = LoggerFactory.getLogger(Xxx.class)```다양한 Logger 인터페이스가 존재하는데 우리가 사용할 것은 SLF4J의 Logger 인터페이스다.           `LoggerFactory.getLogger()`를 통해 SLF4J 구현체를 생성하는데 이때, 현재 클래스 정보를 입력해준다.         위 두 방법 모두 사실은 똑같은 값을 사용하는 것이기에 크게 차이가 없다.**롬복 사용**```java@Slf4jpublic class SampleClass {}```lombok을 의존성 주입 받았다면 간단히 `@Slf4j`만으로도 구현할 수 있다.        이 때 **Logger 참조변수의 이름은 `log`로 사용해야 한다.**<br/>## ⚡️ 로그 호출```java//@Slf4j@RestControllerpublic class LogTestController {    private final Logger log = LoggerFactory.getLogger(getClass());     @RequestMapping("/log-test")    public String logTest() {        String name = "Spring";        log.trace("trace log={}", name);        log.debug("debug log={}", name);        log.info(" info log={}", name);        log.warn(" warn log={}", name);        log.error("error log={}", name);         //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X        log.debug("String concat log=" + name);        return "ok";     }}``````로그가 출력되는 포멧 : 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지```  로그를 호출함에 있어 **로그 레벨**이라는 개념부터 짚고 넘어가고자 한다.         **로그 레벨**이란, **최소 로그 출력 범위**를 나타내는 것으로           **특정 로그 레벨이 지정이 되면 그 이하 로그 레벨을 출력이 되지 않는다.*** **LOG LEVEL:** `TRACE` > `DEBUG` > `INFO` > `WARN` > `ERROR`만약, 애플리케이션의 로그 레벨을 `INFO`로 설정한다면               하위 레벨인 `TRACE`, `DEBUG`는 출력이 되지 않고 `INFO`, `WARN`, `ERROR `이 출력된다.이러한 로그 레벨 설정은 스프링 설정 파일(properties/yml)을 통해 손 쉽게 설정할 수 있다.**application.properties**```properties#전체 로그 레벨 설정(기본 info)logging.level.root=info#hello.springmvc 패키지와 그 하위 로그 레벨 설정logging.level.com.brothergeol.mvc=debug```**root**는 **모든 영역의 로그 레벨을 설정**하며 단 하나의 로그 레벨만을 가질 수 있다.      **명시적인 패키지** 입력은 해당 패키지와 그 하위 패키지에 입력한 로그 레벨이 설정된다.실무에서는 주로 아래와 같은 로그 레벨을 설정한다.* 개발 서버는 debug 출력* 운영 서버는 info 출력로그 레벨 설정을 끝맞췄다면 로그 호출에 대해서 언급하고자 한다.       위 코드에서도 나왔듯이 `log.debug("data="+data)`는 매우 좋지 않은 방법이기에<br/>## ⚡️ 올바른 로그 사용법```java//@Slf4j@RestControllerpublic class LogTestController {     private final Logger logger = LoggerFactory.getLogger(getClass());        @RequestMapping("/log-test")     public String logTest() {      String name = "SpringLogTest";      System.out.println("name = " + name);      logger.trace("info log ={}", name);      logger.debug("info log ={}", name);      logger.info("info log ={}", name);      logger.warn("info log ={}", name);      logger.error("info log ={}", name);      //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X      log.debug("String concat log=" + name);      return "ok";    }}```위 코드에서도 언급했듯이 `log.debug("String concat log=" + name);`는 좋지 않은 방법이다.    로그 레벨이 맞지 않으면 해당 메서드를 호출하지도 않지만,       **연산 로직**이 들어가있다면 로그 레벨이 어떻든지 간에 로직이 일단 실행되기에 별로 좋지않다.* **❌ log.debug("data="+data)**    * 로그 출력 레벨을 info로 설정해도             해당 코드에 있는 **`"data="+data` 가 실제 실행**이 되어 버린다.    * 결과적으로 **문자 더하기 연산이 발생**한다.* **✔ log.debug("data={}", data)**    * 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않는다.    * 따라서 앞과 같은 의미없는 연산이 발생하지 않는다.<br/>## ⚡️ 로그 사용시 장점```javalog.info("hello");System.out.println("hello");```실무에서는 항상 시스템 콘솔 출력 대신 로그를 사용한다.    시스템 콘솔로 직접 출력하는 것 보다 로그를 사용하면 다음과 같은 장점이 있다.* 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.* 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고,      운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.* 시스템 아웃 콘솔에만 출력하는 것이 아니라, **파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.*** **특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.*** 성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다.# 참고로그에 대해서 더 자세한 내용은 slf4j, logback을 검색해보자.* [SLF4J](http://www.slf4j.org)* [Logback](http://logback.qos.ch)스프링 부트가 제공하는 로그 기능은 다음을 참고하자.* [스프링 log docs](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-bootfeatures.html#boot-features-logging)<br/><br/><br/># 💡 요청 매핑## ⚡️@RequestMapping```java@RestControllerpublic class MappingController {    private Logger log = LoggerFactory.getLogger(getClass());        /**    * 기본 요청    * 둘다 허용 /hello-basic, /hello-basic/    * HTTP 메서드 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE    */    @RequestMapping("/hello-basic")    public String helloBasic() {        log.info("helloBasic");        return "ok";    }}```**@RestController*** `@Controller` 는 **반환 값이 `String` 이면 `View 이름`**으로 인식한다. 그래서 뷰를 찾고 뷰가 랜더링 된다.* `@RestController` 는 반환 값으로 View 를 찾는 것이 아니라, **`HTTP Message Body`에 바로 입력**한다.* `@RestController`는 `@ResponseBody` 와 관련이 있는데, 뒤에서 더 자세 설명한다.**@RequestMapping("/hello-basic")*** **매핑**  * `/hello-basic` URL 호출이 오면 이 메서드가 실행되도록 매핑한다.  * 대부분의 속성을 배열[] 로 제공하므로 다중 설정이 가능하다. `{"/hello-basic", "/hello-go"}`    * ~~URL 끝에 `/` 붙어도 이를 생략한 URL로 매핑해준다.~~      * ~~URL 요청: `/hello-basic` , `/hello-basic/`~~      * ~~매핑: /hello-basic~~> ### **스프링 부트 3.0 이후**> 스프링 부트 3.0 부터는 `/hello-basic` , `/hello-basic/` 는 서로 다른 URL 요청을 사용해야 한다.   > 기존에는 마지막에 있는 `/` (slash)를 제거했지만, 스프링 부트 3.0 부터는 마지막의 `/` (slash)를 유지한다.  > 따라서 다음과 같이 다르게 매핑해서 사용해야 한다.> > 매핑: `/hello-basic` ->  URL요청: `/hello-basic`  > 매핑: `/hello-basic/` -> URL요청: `/hello-basic/`* **HTTP 메서드**  * 일반적으로 `@RequestMapping` 에 특정 메서드를 지정하여 사용한다.    ```java    @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)    public String mappingGetV1() {        log.info("mappingGetV1");        return "ok";    }     ```  만약 여기에 POST 요청을 하면 스프링 MVC는 HTTP 405 상태코드(Method Not Allowed)를 반환한다.  * method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다.  * 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE  * method 속성 또한 배열이 가능하므로 여러 HttpMethod를 지원하게 할 수 있다.<br/><br/>## ⚡️HTTP 메서드 매핑 축약```java@GetMapping(value = "/mapping-get-v2")public String mappingGetV2() {    log.info("mapping-get-v2");    return "ok";}```HTTP 메서드를 축약한 애노테이션을 사용하는 것이 더 직관적이다.           내부를 보면 @RequestMapping 과 method 를 지정해서 사용하는 것을 확인할 수 있다.**편리한 축약 애노테이션 (코드보기)*** @GetMapping* @PostMapping* @PutMapping* @DeleteMapping* @PatchMapping<br/><br/>## ⚡️ PathVariable(경로 변수) 사용```java/** * PathVariable 사용 * 변수명이 같으면 생략 가능 * @PathVariable("userId") String userId -> @PathVariable String userId * */@GetMapping("/mapping/{userId}")public String mappingPathVariable(@PathVariable("userId") String userId) {  log.info("mappingPath userId: {}", userId);  return "ok";}````@RequestMapping`은 URL 경로를 템플릿화 할 수 있는데,     `@PathVariable`을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.`@PathVariable`은 템플릿화된 경로의 값을 가져오는데       쉽게 설명하면 URL 에 입력된 경로 문자열을 변수에 담아 데이터로 활용할 수 있는 것을 의미한다.```java@GetMapping("/mapping/{userId}")public String mappingPath(@PathVariable String userId) {    log.info("mappingPath userId={}", data);    return "ok";}```스프링에서는 `@PathVariable`대상 `{}` 템플릿 이름과 파라미터 이름이 같으면        `@PathVariable`어노테이션의 value 속성 값을 생략할 수 있다.                          **단, `@PathVariable`를 생략하면 이는 @ModelAttribute 로직으로 빠지니 주의하자****예시 - 다중 PathVariable 사용**```java@GetMapping("/mapping/users/{userId}/orders/{orderId}")public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {    log.info("mappingPath userId={}, orderId={}", userId, orderId);    return "ok";}```당연하지만 `@PathVariable`은 다중으로 사용할 수 있다.<br/><br/>## ⚡️ 특정 파라미터 조건 매핑```java@GetMapping(value = "/mapping-param", params = "mode=debug")public String mappingParam() {    log.info("mappingParam");    return "ok";}```특정 파라미터(쿼리 스트링)가 있거나 없는 조건을 추가할 수 있다. 잘 사용하지는 않는다.**파라미터로 추가 매핑*** params="mode",* params="!mode"* params="mode=debug"* params="mode!=debug" (! = )* params = {"mode=debug","data=good"}<br/><br/>## ⚡️특정 헤더 조건 매핑```java@GetMapping(value = "/mapping-header", headers = "mode=debug")public String mappingHeader() {    log.info("mappingHeader");    return "ok";}```파라미터 매핑과 비슷하지만, HTTP 헤더를 사용한다.**특정 헤더로 추가 매핑*** headers="mode",* headers="!mode"* headers="mode=debug"* headers="mode!=debug" (! = )<br/><br/>## ⚡️미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume```java@PostMapping(value = "/mapping-consume", consumes = "application/json")public String mappingConsumes() {    log.info("mappingConsumes");    return "ok";}```**Content-Type 헤더 기반 추가 매핑 Media Type*** consumes="application/json"* consumes="!application/json"* consumes="application/*"* consumes="*\/*"* MediaType.APPLICATION_JSON_VALUEHTTP 요청의 Content-Type 헤더를 기반으로 미디어 타입으로 매핑한다.  만약 맞지 않으면 HTTP 415 상태코드(Unsupported Media Type)을 반환한다.<br/><br/>## ⚡️미디어 타입 조건 매핑 - HTTP 요청 Accept, produce```java@PostMapping(value = "/mapping-produce", produces = "text/html")public String mappingProduces() {    log.info("mappingProduces");    return "ok";}```HTTP 요청의 Accept 헤더를 기반으로 미디어 타입으로 매핑한다.   만약 맞지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환한다.   (클라이언트가 클라이언트에서 받아들일 수 있는 형태를 알려준 것)**Accept 헤더 기반 Media Type*** produces = "text/html"* produces = "!text/html"* produces = "text/*"* produces = "*\/*"예시)       produces = "text/plain"    produces = {"text/plain", "application/*"}     produces = MediaType.TEXT_PLAIN_VALUE      produces = "text/plain;charset=UTF-8"           <br/><br/><br/># 💡 요청 매핑 - API 예시**회원 관리 API*** 회원 목록 조회: `GET /users`* 회원 등록: `POST /users`* 회원 조회: `GET /users/{userId}`* 회원 수정: `PATCH /users/{userId}`* 회원 삭제: `DELETE /users/{userId}````java@RestController@RequestMapping("/mapping/users")public class MappingClassController {     /**     * GET /mapping/users     */     @GetMapping     public String users() {         return "get users";     }     /**     * POST /mapping/users     */     @PostMapping     public String addUser() {         return "post user";     }     /**     * GET /mapping/users/{userId}     */     @GetMapping("/{userId}")     public String findUser(@PathVariable String userId) {         return "get userId=" + userId;     }     /**     * PATCH /mapping/users/{userId}     */     @PatchMapping("/{userId}")     public String updateUser(@PathVariable String userId) {         return "update userId=" + userId;     }     /**     * DELETE /mapping/users/{userId}     */     @DeleteMapping("/{userId}")     public String deleteUser(@PathVariable String userId) {        return "delete userId=" + userId;    }}```**@RequestMapping("/mapping/users")**    클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용한다.* 회원 목록 조회: `GET /mapping/users`* 회원 등록: `POST /mapping/users`* 회원 조회: `GET /mapping/users/id1`* 회원 수정: `PATCH /mapping/users/id1`* 회원 삭제: `DELETE /mapping/users/id1`매핑 방법을 이해했으니, 이제부터 HTTP 요청이 보내는 데이터들을 스프링 MVC로 어떻게 조회하는지 알아보자.<br/><br/><br/># 💡HTTP 요청 - 기본, 헤더 조회어노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다.    이번에는 HTTP 헤더 정보를 조회하는 방법을 알아보고자 한다.```java@Slf4j@RestControllerpublic class RequestHeaderController {    @RequestMapping("/headers")    public String headers(            HttpServletRequest request,            HttpServletResponse response,            HttpMethod httpMethod,            Locale locale,            @RequestHeader MultiValueMap<String, String> headerMap,            @RequestHeader("host") String host,            @CookieValue(value = "myCookie", required = false) String cookie) {                log.info("request={}", request);        log.info("response={}", response);        log.info("httpMethod={}", httpMethod);        log.info("locale={}", locale);        log.info("headerMap={}", headerMap);        log.info("header host={}", host);        log.info("myCookie={}", cookie);                return "ok";    }}```  * **HttpServletRequest**     Servlet에서 제공하는 HttpServletRequest 객체* **HttpServletResponse**        Servlet에서 제공하는 HttpServletResponse 객체* **HttpMethod**        `org.springframework.http.HttpMethod`         HTTP 메서드(GET/POST 등등)를 조회할 때 사용하는 객체* **Locale**      Locale(지역) 정보를 조회하고 주로 국제화할 때 사용한다.* **@RequestHeader MultiValueMap<String, String> headerMap**        모든 HTTP 헤더를 Key와 다중 Value인, MultiValueMap 형식으로 조회한다.* **@RequestHeader("host") String host**        특정 HTTP 헤더를 조회한다.  * 필수 값 여부: required  * 기본 값 속성: defaultValue* **@CookieValue(value = "myCookie", required = false) String cookie**            특정 쿠키를 조회한다.  * 필수 값 여부: required  * 기본 값: defaultValue* **MultiValueMap**     MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.        HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.  ```http  keyA=value1&keyA=value2  ```  ```java  MultiValueMap<String, String> map = new LinkedMultiValueMap();  map.add("keyA", "value1");  map.add("keyA", "value2");    //[value1,value2]  List<String> values = map.get("keyA");  ```**참고*** @Conroller 의 사용 가능한 파라미터 목록은 다음 [공식 메뉴얼](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-annarguments)에서 확인할 수 있다.* @Conroller 의 사용 가능한 응답 값 목록은 다음 [공식 메뉴얼](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-annreturn-types)에서 확인할 수 있다.<br/><br/><br/># 💡HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다.**GET - 쿼리 파라미터*** `/url?username=hello&age=20`* 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달* 예) 검색, 필터, 페이징등에서 많이 사용하는 방식**POST - HTML Form*** `content-type: application/x-www-form-urlencoded`* 메시지 바디에 쿼리 파리미터 형식으로 전달 `username=hello&age=20`* 예) 회원 가입, 상품 주문, HTML Form 사용**HTTP message body에 데이터를 직접 담아서 요청*** HTTP API에서 주로 사용, `JSON`, `XML`, `TEXT`* 데이터 형식은 주로 JSON 사용* `POST`, `PUT`, `PATCH`**요청 파라미터 - 쿼리 파라미터, HTML Form**    `HttpServletRequest` 의 `request.getParameter()`를 사용하면 다음 두가지 요청 파라미터를 조회할 수 있다.* GET 쿼리 파리미터 전송 방식* POST HTML Form 전송 방식파라미터 바인딩의 대상은 `Get`/`POST form` 두 요청에 한해서고      만약, **Post Json 방식으로 요청을 보낸다면 파라미터 바인딩의 대상이 되지 않는다.**```httpPOST /request-param ...content-type: application/x-www-form-urlencodedusername=hello&age=20```  `GET 쿼리 파리미터` 전송 방식이든, `POST HTML Form` 전송 방식이든         사실상 둘다 형식이 같으므로 구분없이 조회할 수 있다.       **이것을 간단히 요청 파라미터(request parameter) 조회라 한다.**```java@Slf4j@Controllerpublic class RequestParamController {    /**    * 반환 타입이 없으면서 이렇게 응답에 값을 직접 집어넣으면, view 조회X    */    @RequestMapping("/request-param-v1")    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {        String username = request.getParameter("username");        int age = Integer.parseInt(request.getParameter("age"));        log.info("username={}, age={}", username, age);        response.getWriter().write("ok");    }}```위 코드를 테스트하기 위한 html 을 작성해보면 아래와 같다.     참고로 **정적 리소스**는 `/resources/static` 아래에 두면 스프링 부트가 자동으로 인식한다.```html<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>Title</title></head><body>    <form action="/request-param-v1" method="post">        username: <input type="text" name="username" />        age: <input type="text" name="age" />        <button type="submit">전송</button>    </form></body></html>```> ### **참고**   > Jar 를 사용하면 webapp 경로를 사용할 수 없다.      > 이제부터 정적 리소스도 클래스 경로에 함께 포함해야 한다.    