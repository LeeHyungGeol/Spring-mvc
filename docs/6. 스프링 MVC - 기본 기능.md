# 스프링 MVC - 기본 기능<br/>## 목차- 로깅 - SLF4J, Logback- 요청 매핑<br/><br/><br/># 💡로깅 > 운영 시스템에서는, 일반적인 콘솔 출력(sout) 대신 **로깅 라이브러리**를 사용해서 **로그를 출력**한다.<br/>## ⚡️ 로깅 라이브러리 - SLF4J, Logback스프링 부트는 기본적으로 `spring-boot-starter-logging` 라이브러리를 제공한다.**스프링 부트 로깅 라이브러리*** SLF4J - http://www.slf4j.org* Logback - http://logback.qos.ch`SLF4J`는 다양한 로깅 라이브러리를 사용할 수 있도록 정의된 **통합 로그 인터페이스다.**                  구현체로는 `Logback`, `Log4J`, `Log4J2` 등등이 있으며 **스프링 부트는 `Logback`를 지원해준다.**              **즉, 스프링부트는 SLF4J 인터페이스 및 LogBack 구현체를 제공해 로깅 기능을 지원해준다는 의미이다.**<br/>## ⚡️ 로그 선언**방법1**```javaprivate Logger log = LoggerFactory.getLogger(getClass());```**방법2**```javaprivate static final Logger log = LoggerFactory.getLogger(Xxx.class)```다양한 Logger 인터페이스가 존재하는데 우리가 사용할 것은 SLF4J의 Logger 인터페이스다.           `LoggerFactory.getLogger()`를 통해 SLF4J 구현체를 생성하는데 이때, 현재 클래스 정보를 입력해준다.         위 두 방법 모두 사실은 똑같은 값을 사용하는 것이기에 크게 차이가 없다.**롬복 사용**```java@Slf4jpublic class SampleClass {}```lombok을 의존성 주입 받았다면 간단히 `@Slf4j`만으로도 구현할 수 있다.        이 때 **Logger 참조변수의 이름은 `log`로 사용해야 한다.**<br/>## ⚡️ 로그 호출```java//@Slf4j@RestControllerpublic class LogTestController {    private final Logger log = LoggerFactory.getLogger(getClass());     @RequestMapping("/log-test")    public String logTest() {        String name = "Spring";        log.trace("trace log={}", name);        log.debug("debug log={}", name);        log.info(" info log={}", name);        log.warn(" warn log={}", name);        log.error("error log={}", name);         //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X        log.debug("String concat log=" + name);        return "ok";     }}``````로그가 출력되는 포멧 : 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지```  로그를 호출함에 있어 **로그 레벨**이라는 개념부터 짚고 넘어가고자 한다.         **로그 레벨**이란, **최소 로그 출력 범위**를 나타내는 것으로           **특정 로그 레벨이 지정이 되면 그 이하 로그 레벨을 출력이 되지 않는다.*** **LOG LEVEL:** `TRACE` > `DEBUG` > `INFO` > `WARN` > `ERROR`만약, 애플리케이션의 로그 레벨을 `INFO`로 설정한다면               하위 레벨인 `TRACE`, `DEBUG`는 출력이 되지 않고 `INFO`, `WARN`, `ERROR `이 출력된다.이러한 로그 레벨 설정은 스프링 설정 파일(properties/yml)을 통해 손 쉽게 설정할 수 있다.**application.properties**```properties#전체 로그 레벨 설정(기본 info)logging.level.root=info#hello.springmvc 패키지와 그 하위 로그 레벨 설정logging.level.com.brothergeol.mvc=debug```**root**는 **모든 영역의 로그 레벨을 설정**하며 단 하나의 로그 레벨만을 가질 수 있다.      **명시적인 패키지** 입력은 해당 패키지와 그 하위 패키지에 입력한 로그 레벨이 설정된다.실무에서는 주로 아래와 같은 로그 레벨을 설정한다.* 개발 서버는 debug 출력* 운영 서버는 info 출력로그 레벨 설정을 끝맞췄다면 로그 호출에 대해서 언급하고자 한다.       위 코드에서도 나왔듯이 `log.debug("data="+data)`는 매우 좋지 않은 방법이기에<br/>## ⚡️ 올바른 로그 사용법```java//@Slf4j@RestControllerpublic class LogTestController {     private final Logger logger = LoggerFactory.getLogger(getClass());        @RequestMapping("/log-test")     public String logTest() {      String name = "SpringLogTest";      System.out.println("name = " + name);      logger.trace("info log ={}", name);      logger.debug("info log ={}", name);      logger.info("info log ={}", name);      logger.warn("info log ={}", name);      logger.error("info log ={}", name);      //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X      log.debug("String concat log=" + name);      return "ok";    }}```위 코드에서도 언급했듯이 `log.debug("String concat log=" + name);`는 좋지 않은 방법이다.    로그 레벨이 맞지 않으면 해당 메서드를 호출하지도 않지만,       **연산 로직**이 들어가있다면 로그 레벨이 어떻든지 간에 로직이 일단 실행되기에 별로 좋지않다.* **❌ log.debug("data="+data)**    * 로그 출력 레벨을 info로 설정해도             해당 코드에 있는 **`"data="+data` 가 실제 실행**이 되어 버린다.    * 결과적으로 **문자 더하기 연산이 발생**한다.* **✔ log.debug("data={}", data)**    * 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않는다.    * 따라서 앞과 같은 의미없는 연산이 발생하지 않는다.<br/>## ⚡️ 로그 사용시 장점```javalog.info("hello");System.out.println("hello");```실무에서는 항상 시스템 콘솔 출력 대신 로그를 사용한다.    시스템 콘솔로 직접 출력하는 것 보다 로그를 사용하면 다음과 같은 장점이 있다.* 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.* 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고,      운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.* 시스템 아웃 콘솔에만 출력하는 것이 아니라, **파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다.*** **특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.*** 성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다.# 참고로그에 대해서 더 자세한 내용은 slf4j, logback을 검색해보자.* [SLF4J](http://www.slf4j.org)* [Logback](http://logback.qos.ch)스프링 부트가 제공하는 로그 기능은 다음을 참고하자.* [스프링 log docs](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-bootfeatures.html#boot-features-logging)<br/><br/><br/># 💡 요청 매핑## ⚡️@RequestMapping```java@RestControllerpublic class MappingController {    private Logger log = LoggerFactory.getLogger(getClass());        /**    * 기본 요청    * 둘다 허용 /hello-basic, /hello-basic/    * HTTP 메서드 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE    */    @RequestMapping("/hello-basic")    public String helloBasic() {        log.info("helloBasic");        return "ok";    }}```**@RestController*** `@Controller` 는 **반환 값이 `String` 이면 `View 이름`**으로 인식한다. 그래서 뷰를 찾고 뷰가 랜더링 된다.* `@RestController` 는 반환 값으로 View 를 찾는 것이 아니라, **`HTTP Message Body`에 바로 입력**한다.* `@RestController`는 `@ResponseBody` 와 관련이 있는데, 뒤에서 더 자세 설명한다.**@RequestMapping("/hello-basic")*** **매핑**  * `/hello-basic` URL 호출이 오면 이 메서드가 실행되도록 매핑한다.  * 대부분의 속성을 배열[] 로 제공하므로 다중 설정이 가능하다. `{"/hello-basic", "/hello-go"}`    * ~~URL 끝에 `/` 붙어도 이를 생략한 URL로 매핑해준다.~~      * ~~URL 요청: `/hello-basic` , `/hello-basic/`~~      * ~~매핑: /hello-basic~~> ### **스프링 부트 3.0 이후**> 스프링 부트 3.0 부터는 `/hello-basic` , `/hello-basic/` 는 서로 다른 URL 요청을 사용해야 한다.   > 기존에는 마지막에 있는 `/` (slash)를 제거했지만, 스프링 부트 3.0 부터는 마지막의 `/` (slash)를 유지한다.  > 따라서 다음과 같이 다르게 매핑해서 사용해야 한다.> > 매핑: `/hello-basic` ->  URL요청: `/hello-basic`  > 매핑: `/hello-basic/` -> URL요청: `/hello-basic/`* **HTTP 메서드**  * 일반적으로 `@RequestMapping` 에 특정 메서드를 지정하여 사용한다.    ```java    @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)    public String mappingGetV1() {        log.info("mappingGetV1");        return "ok";    }     ```  만약 여기에 POST 요청을 하면 스프링 MVC는 HTTP 405 상태코드(Method Not Allowed)를 반환한다.  * method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다.  * 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE  * method 속성 또한 배열이 가능하므로 여러 HttpMethod를 지원하게 할 수 있다.<br/><br/>## ⚡️HTTP 메서드 매핑 축약```java@GetMapping(value = "/mapping-get-v2")public String mappingGetV2() {    log.info("mapping-get-v2");    return "ok";}```HTTP 메서드를 축약한 애노테이션을 사용하는 것이 더 직관적이다.           내부를 보면 @RequestMapping 과 method 를 지정해서 사용하는 것을 확인할 수 있다.**편리한 축약 애노테이션 (코드보기)*** @GetMapping* @PostMapping* @PutMapping* @DeleteMapping* @PatchMapping<br/><br/>## ⚡️ PathVariable(경로 변수) 사용```java/** * PathVariable 사용 * 변수명이 같으면 생략 가능 * @PathVariable("userId") String userId -> @PathVariable String userId * */@GetMapping("/mapping/{userId}")public String mappingPathVariable(@PathVariable("userId") String userId) {  log.info("mappingPath userId: {}", userId);  return "ok";}````@RequestMapping`은 URL 경로를 템플릿화 할 수 있는데,     `@PathVariable`을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.`@PathVariable`은 템플릿화된 경로의 값을 가져오는데       쉽게 설명하면 URL 에 입력된 경로 문자열을 변수에 담아 데이터로 활용할 수 있는 것을 의미한다.```java@GetMapping("/mapping/{userId}")public String mappingPath(@PathVariable String userId) {    log.info("mappingPath userId={}", data);    return "ok";}```스프링에서는 `@PathVariable`대상 `{}` 템플릿 이름과 파라미터 이름이 같으면        `@PathVariable`어노테이션의 value 속성 값을 생략할 수 있다.                          **단, `@PathVariable`를 생략하면 이는 @ModelAttribute 로직으로 빠지니 주의하자****예시 - 다중 PathVariable 사용**```java@GetMapping("/mapping/users/{userId}/orders/{orderId}")public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {    log.info("mappingPath userId={}, orderId={}", userId, orderId);    return "ok";}```당연하지만 `@PathVariable`은 다중으로 사용할 수 있다.<br/><br/>## ⚡️ 특정 파라미터 조건 매핑```java@GetMapping(value = "/mapping-param", params = "mode=debug")public String mappingParam() {    log.info("mappingParam");    return "ok";}```특정 파라미터(쿼리 스트링)가 있거나 없는 조건을 추가할 수 있다. 잘 사용하지는 않는다.**파라미터로 추가 매핑*** params="mode",* params="!mode"* params="mode=debug"* params="mode!=debug" (! = )* params = {"mode=debug","data=good"}<br/><br/>## ⚡️특정 헤더 조건 매핑```java@GetMapping(value = "/mapping-header", headers = "mode=debug")public String mappingHeader() {    log.info("mappingHeader");    return "ok";}```파라미터 매핑과 비슷하지만, HTTP 헤더를 사용한다.**특정 헤더로 추가 매핑*** headers="mode",* headers="!mode"* headers="mode=debug"* headers="mode!=debug" (! = )<br/><br/>## ⚡️미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume```java@PostMapping(value = "/mapping-consume", consumes = "application/json")public String mappingConsumes() {    log.info("mappingConsumes");    return "ok";}```**Content-Type 헤더 기반 추가 매핑 Media Type*** consumes="application/json"* consumes="!application/json"* consumes="application/*"* consumes="*\/*"* MediaType.APPLICATION_JSON_VALUEHTTP 요청의 Content-Type 헤더를 기반으로 미디어 타입으로 매핑한다.  만약 맞지 않으면 HTTP 415 상태코드(Unsupported Media Type)을 반환한다.<br/><br/>## ⚡️미디어 타입 조건 매핑 - HTTP 요청 Accept, produce```java@PostMapping(value = "/mapping-produce", produces = "text/html")public String mappingProduces() {    log.info("mappingProduces");    return "ok";}```HTTP 요청의 Accept 헤더를 기반으로 미디어 타입으로 매핑한다.   만약 맞지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환한다.   (클라이언트가 클라이언트에서 받아들일 수 있는 형태를 알려준 것)**Accept 헤더 기반 Media Type*** produces = "text/html"* produces = "!text/html"* produces = "text/*"* produces = "*\/*"예시)       produces = "text/plain"    produces = {"text/plain", "application/*"}     produces = MediaType.TEXT_PLAIN_VALUE      produces = "text/plain;charset=UTF-8"           <br/><br/><br/>